"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GCPMachineWorkflow = void 0;
const error_1 = require("../../../error");
const utils_1 = require("../../../utils");
const machine_workflow_1 = require("./machine_workflow");
/** GCP base URL. */
const GCP_BASE_URL = 'http://metadata/computeMetadata/v1/instance/service-accounts/default/identity';
/** GCP request headers. */
const GCP_HEADERS = Object.freeze({ 'Metadata-Flavor': 'Google' });
/** Error for when the token audience is missing in the environment. */
const TOKEN_RESOURCE_MISSING_ERROR = 'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is gcp.';
class GCPMachineWorkflow extends machine_workflow_1.MachineWorkflow {
    /**
     * Instantiate the machine workflow.
     */
    constructor(cache) {
        super(cache);
    }
    /**
     * Get the token from the environment.
     */
    getToken(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenAudience = credentials === null || credentials === void 0 ? void 0 : credentials.mechanismProperties.TOKEN_RESOURCE;
            if (!tokenAudience) {
                throw new error_1.MongoGCPError(TOKEN_RESOURCE_MISSING_ERROR);
            }
            return yield getGcpTokenData(tokenAudience);
        });
    }
}
exports.GCPMachineWorkflow = GCPMachineWorkflow;
/**
 * Hit the GCP endpoint to get the token data.
 */
function getGcpTokenData(tokenAudience) {
    return __awaiter(this, void 0, void 0, function* () {
        const url = new URL(GCP_BASE_URL);
        url.searchParams.append('audience', tokenAudience);
        const response = yield (0, utils_1.get)(url, {
            headers: GCP_HEADERS
        });
        if (response.status !== 200) {
            throw new error_1.MongoGCPError(`Status code ${response.status} returned from the GCP endpoint. Response body: ${response.body}`);
        }
        return { access_token: response.body };
    });
}
