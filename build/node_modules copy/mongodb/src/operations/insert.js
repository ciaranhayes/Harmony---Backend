"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;
const error_1 = require("../error");
const utils_1 = require("../utils");
const write_concern_1 = require("../write_concern");
const bulk_write_1 = require("./bulk_write");
const command_1 = require("./command");
const operation_1 = require("./operation");
/** @internal */
class InsertOperation extends command_1.CommandOperation {
    constructor(ns, documents, options) {
        var _a;
        super(undefined, options);
        this.options = Object.assign(Object.assign({}, options), { checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false });
        this.ns = ns;
        this.documents = documents;
    }
    get commandName() {
        return 'insert';
    }
    execute(server, session, timeoutContext) {
        const _super = Object.create(null, {
            executeCommand: { get: () => super.executeCommand }
        });
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
            const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;
            const command = {
                insert: this.ns.collection,
                documents: this.documents,
                ordered
            };
            if (typeof options.bypassDocumentValidation === 'boolean') {
                command.bypassDocumentValidation = options.bypassDocumentValidation;
            }
            // we check for undefined specifically here to allow falsy values
            // eslint-disable-next-line no-restricted-syntax
            if (options.comment !== undefined) {
                command.comment = options.comment;
            }
            return yield _super.executeCommand.call(this, server, session, command, timeoutContext);
        });
    }
}
exports.InsertOperation = InsertOperation;
class InsertOneOperation extends InsertOperation {
    constructor(collection, doc, options) {
        super(collection.s.namespace, (0, utils_1.maybeAddIdToDocuments)(collection, [doc], options), options);
    }
    execute(server, session, timeoutContext) {
        const _super = Object.create(null, {
            execute: { get: () => super.execute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const res = yield _super.execute.call(this, server, session, timeoutContext);
            if (res.code)
                throw new error_1.MongoServerError(res);
            if (res.writeErrors) {
                // This should be a WriteError but we can't change it now because of error hierarchy
                throw new error_1.MongoServerError(res.writeErrors[0]);
            }
            return {
                acknowledged: ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0,
                insertedId: this.documents[0]._id
            };
        });
    }
}
exports.InsertOneOperation = InsertOneOperation;
/** @internal */
class InsertManyOperation extends operation_1.AbstractOperation {
    constructor(collection, docs, options) {
        super(options);
        if (!Array.isArray(docs)) {
            throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
        }
        this.options = options;
        this.collection = collection;
        this.docs = docs;
    }
    get commandName() {
        return 'insert';
    }
    execute(server, session, timeoutContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const coll = this.collection;
            const options = Object.assign(Object.assign(Object.assign({}, this.options), this.bsonOptions), { readPreference: this.readPreference });
            const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
            const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, this.docs.map(document => ({
                insertOne: { document }
            })), options);
            try {
                const res = yield bulkWriteOperation.execute(server, session, timeoutContext);
                return {
                    acknowledged: (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0,
                    insertedCount: res.insertedCount,
                    insertedIds: res.insertedIds
                };
            }
            catch (err) {
                if (err && err.message === 'Operation must be an object with an operation key') {
                    throw new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');
                }
                throw err;
            }
        });
    }
}
exports.InsertManyOperation = InsertManyOperation;
(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
