"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;
const error_1 = require("../error");
const command_1 = require("./command");
const operation_1 = require("./operation");
/** @internal */
class DropCollectionOperation extends command_1.CommandOperation {
    constructor(db, name, options = {}) {
        super(db, options);
        this.db = db;
        this.options = options;
        this.name = name;
    }
    get commandName() {
        return 'drop';
    }
    execute(server, session, timeoutContext) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const db = this.db;
            const options = this.options;
            const name = this.name;
            const encryptedFieldsMap = (_a = db.client.s.options.autoEncryption) === null || _a === void 0 ? void 0 : _a.encryptedFieldsMap;
            let encryptedFields = (_b = options.encryptedFields) !== null && _b !== void 0 ? _b : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap[`${db.databaseName}.${name}`];
            if (!encryptedFields && encryptedFieldsMap) {
                // If the MongoClient was configured with an encryptedFieldsMap,
                // and no encryptedFields config was available in it or explicitly
                // passed as an argument, the spec tells us to look one up using
                // listCollections().
                const listCollectionsResult = yield db
                    .listCollections({ name }, { nameOnly: false })
                    .toArray();
                encryptedFields = (_d = (_c = listCollectionsResult === null || listCollectionsResult === void 0 ? void 0 : listCollectionsResult[0]) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.encryptedFields;
            }
            if (encryptedFields) {
                const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
                const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
                for (const collectionName of [escCollection, ecocCollection]) {
                    // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.
                    const dropOp = new DropCollectionOperation(db, collectionName);
                    try {
                        yield dropOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
                    }
                    catch (err) {
                        if (!(err instanceof error_1.MongoServerError) ||
                            err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
                            throw err;
                        }
                    }
                }
            }
            return yield this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
        });
    }
    executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {
        const _super = Object.create(null, {
            executeCommand: { get: () => super.executeCommand }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.executeCommand.call(this, server, session, { drop: this.name }, timeoutContext);
            return true;
        });
    }
}
exports.DropCollectionOperation = DropCollectionOperation;
/** @internal */
class DropDatabaseOperation extends command_1.CommandOperation {
    constructor(db, options) {
        super(db, options);
        this.options = options;
    }
    get commandName() {
        return 'dropDatabase';
    }
    execute(server, session, timeoutContext) {
        const _super = Object.create(null, {
            executeCommand: { get: () => super.executeCommand }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.executeCommand.call(this, server, session, { dropDatabase: 1 }, timeoutContext);
            return true;
        });
    }
}
exports.DropDatabaseOperation = DropDatabaseOperation;
(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
