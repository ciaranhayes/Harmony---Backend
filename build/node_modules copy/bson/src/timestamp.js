"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timestamp = exports.LongWithoutOverridesClass = void 0;
const error_1 = require("./error");
const long_1 = require("./long");
const utils_1 = require("./parser/utils");
/** @public */
exports.LongWithoutOverridesClass = long_1.Long;
/**
 * @public
 * @category BSONType
 *
 * A special type for _internal_ MongoDB use and is **not** associated with the regular Date type.
 */
class Timestamp extends exports.LongWithoutOverridesClass {
    get _bsontype() {
        return 'Timestamp';
    }
    /**
     * An incrementing ordinal for operations within a given second.
     */
    get i() {
        return this.low >>> 0;
    }
    /**
     * A `time_t` value measuring seconds since the Unix epoch
     */
    get t() {
        return this.high >>> 0;
    }
    constructor(low) {
        if (low == null) {
            super(0, 0, true);
        }
        else if (typeof low === 'bigint') {
            super(low, true);
        }
        else if (long_1.Long.isLong(low)) {
            super(low.low, low.high, true);
        }
        else if (typeof low === 'object' && 't' in low && 'i' in low) {
            if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide t as a number');
            }
            if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide i as a number');
            }
            const t = Number(low.t);
            const i = Number(low.i);
            if (t < 0 || Number.isNaN(t)) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide a positive t');
            }
            if (i < 0 || Number.isNaN(i)) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide a positive i');
            }
            if (t > 4294967295) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');
            }
            if (i > 4294967295) {
                throw new error_1.BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');
            }
            super(i, t, true);
        }
        else {
            throw new error_1.BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');
        }
    }
    toJSON() {
        return {
            $timestamp: this.toString()
        };
    }
    /** Returns a Timestamp represented by the given (32-bit) integer value. */
    static fromInt(value) {
        return new Timestamp(long_1.Long.fromInt(value, true));
    }
    /** Returns a Timestamp representing the given number value, provided that it is a finite number. Otherwise, zero is returned. */
    static fromNumber(value) {
        return new Timestamp(long_1.Long.fromNumber(value, true));
    }
    /**
     * Returns a Timestamp for the given high and low bits. Each is assumed to use 32 bits.
     *
     * @param lowBits - the low 32-bits.
     * @param highBits - the high 32-bits.
     */
    static fromBits(lowBits, highBits) {
        return new Timestamp({ i: lowBits, t: highBits });
    }
    /**
     * Returns a Timestamp from the given string, optionally using the given radix.
     *
     * @param str - the textual representation of the Timestamp.
     * @param optRadix - the radix in which the text is written.
     */
    static fromString(str, optRadix) {
        return new Timestamp(long_1.Long.fromString(str, true, optRadix));
    }
    /** @internal */
    toExtendedJSON() {
        return { $timestamp: { t: this.t, i: this.i } };
    }
    /** @internal */
    static fromExtendedJSON(doc) {
        // The Long check is necessary because extended JSON has different behavior given the size of the input number
        const i = long_1.Long.isLong(doc.$timestamp.i)
            ? doc.$timestamp.i.getLowBitsUnsigned() // Need to fetch the least significant 32 bits
            : doc.$timestamp.i;
        const t = long_1.Long.isLong(doc.$timestamp.t)
            ? doc.$timestamp.t.getLowBitsUnsigned() // Need to fetch the least significant 32 bits
            : doc.$timestamp.t;
        return new Timestamp({ t, i });
    }
    inspect(depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : (inspect = utils_1.defaultInspect);
        const t = inspect(this.t, options);
        const i = inspect(this.i, options);
        return `new Timestamp({ t: ${t}, i: ${i} })`;
    }
}
exports.Timestamp = Timestamp;
Timestamp.MAX_VALUE = long_1.Long.MAX_UNSIGNED_VALUE;
