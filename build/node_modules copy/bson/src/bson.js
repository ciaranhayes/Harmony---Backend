"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onDemand = exports.EJSON = exports.BSONType = exports.BSONOffsetError = exports.BSONRuntimeError = exports.BSONVersionError = exports.BSONError = exports.BSONValue = exports.Decimal128 = exports.BSONRegExp = exports.MaxKey = exports.MinKey = exports.Int32 = exports.Double = exports.Timestamp = exports.Long = exports.UUID = exports.ObjectId = exports.Binary = exports.DBRef = exports.BSONSymbol = exports.Code = void 0;
exports.setInternalBufferSize = setInternalBufferSize;
exports.serialize = serialize;
exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
exports.deserialize = deserialize;
exports.calculateObjectSize = calculateObjectSize;
exports.deserializeStream = deserializeStream;
const binary_1 = require("./binary");
Object.defineProperty(exports, "Binary", { enumerable: true, get: function () { return binary_1.Binary; } });
Object.defineProperty(exports, "UUID", { enumerable: true, get: function () { return binary_1.UUID; } });
const code_1 = require("./code");
Object.defineProperty(exports, "Code", { enumerable: true, get: function () { return code_1.Code; } });
const db_ref_1 = require("./db_ref");
Object.defineProperty(exports, "DBRef", { enumerable: true, get: function () { return db_ref_1.DBRef; } });
const decimal128_1 = require("./decimal128");
Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function () { return decimal128_1.Decimal128; } });
const double_1 = require("./double");
Object.defineProperty(exports, "Double", { enumerable: true, get: function () { return double_1.Double; } });
const int_32_1 = require("./int_32");
Object.defineProperty(exports, "Int32", { enumerable: true, get: function () { return int_32_1.Int32; } });
const long_1 = require("./long");
Object.defineProperty(exports, "Long", { enumerable: true, get: function () { return long_1.Long; } });
const max_key_1 = require("./max_key");
Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function () { return max_key_1.MaxKey; } });
const min_key_1 = require("./min_key");
Object.defineProperty(exports, "MinKey", { enumerable: true, get: function () { return min_key_1.MinKey; } });
const objectid_1 = require("./objectid");
Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function () { return objectid_1.ObjectId; } });
const calculate_size_1 = require("./parser/calculate_size");
// Parts of the parser
const deserializer_1 = require("./parser/deserializer");
const serializer_1 = require("./parser/serializer");
const regexp_1 = require("./regexp");
Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function () { return regexp_1.BSONRegExp; } });
const symbol_1 = require("./symbol");
Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function () { return symbol_1.BSONSymbol; } });
const timestamp_1 = require("./timestamp");
Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function () { return timestamp_1.Timestamp; } });
const byte_utils_1 = require("./utils/byte_utils");
const number_utils_1 = require("./utils/number_utils");
var bson_value_1 = require("./bson_value");
Object.defineProperty(exports, "BSONValue", { enumerable: true, get: function () { return bson_value_1.BSONValue; } });
var error_1 = require("./error");
Object.defineProperty(exports, "BSONError", { enumerable: true, get: function () { return error_1.BSONError; } });
Object.defineProperty(exports, "BSONVersionError", { enumerable: true, get: function () { return error_1.BSONVersionError; } });
Object.defineProperty(exports, "BSONRuntimeError", { enumerable: true, get: function () { return error_1.BSONRuntimeError; } });
Object.defineProperty(exports, "BSONOffsetError", { enumerable: true, get: function () { return error_1.BSONOffsetError; } });
var constants_1 = require("./constants");
Object.defineProperty(exports, "BSONType", { enumerable: true, get: function () { return constants_1.BSONType; } });
var extended_json_1 = require("./extended_json");
Object.defineProperty(exports, "EJSON", { enumerable: true, get: function () { return extended_json_1.EJSON; } });
var index_1 = require("./parser/on_demand/index");
Object.defineProperty(exports, "onDemand", { enumerable: true, get: function () { return index_1.onDemand; } });
/** @internal */
// Default Max Size
const MAXSIZE = 1024 * 1024 * 17;
// Current Internal Temporary Serialization Buffer
let buffer = byte_utils_1.ByteUtils.allocate(MAXSIZE);
/**
 * Sets the size of the internal serialization buffer.
 *
 * @param size - The desired size for the internal serialization buffer in bytes
 * @public
 */
function setInternalBufferSize(size) {
    // Resize the internal serialization buffer if needed
    if (buffer.length < size) {
        buffer = byte_utils_1.ByteUtils.allocate(size);
    }
}
/**
 * Serialize a Javascript object.
 *
 * @param object - the Javascript object to serialize.
 * @returns Buffer object containing the serialized object.
 * @public
 */
function serialize(object, options = {}) {
    // Unpack the options
    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
    const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;
    // Resize the internal serialization buffer if needed
    if (buffer.length < minInternalBufferSize) {
        buffer = byte_utils_1.ByteUtils.allocate(minInternalBufferSize);
    }
    // Attempt to serialize
    const serializationIndex = (0, serializer_1.serializeInto)(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    // Create the final buffer
    const finishedBuffer = byte_utils_1.ByteUtils.allocateUnsafe(serializationIndex);
    // Copy into the finished buffer
    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
    // Return the buffer
    return finishedBuffer;
}
/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer,
 * useful when pre-allocating the space for serialization.
 *
 * @param object - the Javascript object to serialize.
 * @param finalBuffer - the Buffer you pre-allocated to store the serialized BSON object.
 * @returns the index pointing to the last written byte in the buffer.
 * @public
 */
function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
    // Unpack the options
    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
    const startIndex = typeof options.index === 'number' ? options.index : 0;
    // Attempt to serialize
    const serializationIndex = (0, serializer_1.serializeInto)(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
    // Return the index
    return startIndex + serializationIndex - 1;
}
/**
 * Deserialize data as BSON.
 *
 * @param buffer - the buffer containing the serialized set of BSON documents.
 * @returns returns the deserialized Javascript Object.
 * @public
 */
function deserialize(buffer, options = {}) {
    return (0, deserializer_1.internalDeserialize)(byte_utils_1.ByteUtils.toLocalBufferType(buffer), options);
}
/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param object - the Javascript object to calculate the BSON byte size for
 * @returns size of BSON object in bytes
 * @public
 */
function calculateObjectSize(object, options = {}) {
    options = options || {};
    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
    return (0, calculate_size_1.internalCalculateObjectSize)(object, serializeFunctions, ignoreUndefined);
}
/**
 * Deserialize stream data as BSON documents.
 *
 * @param data - the buffer containing the serialized set of BSON documents.
 * @param startIndex - the start index in the data Buffer where the deserialization is to start.
 * @param numberOfDocuments - number of documents to deserialize.
 * @param documents - an array where to store the deserialized documents.
 * @param docStartIndex - the index in the documents array from where to start inserting documents.
 * @param options - additional options used for the deserialization.
 * @returns next index in the buffer after deserialization **x** numbers of documents.
 * @public
 */
function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
    const bufferData = byte_utils_1.ByteUtils.toLocalBufferType(data);
    let index = startIndex;
    // Loop over all documents
    for (let i = 0; i < numberOfDocuments; i++) {
        // Find size of the document
        const size = number_utils_1.NumberUtils.getInt32LE(bufferData, index);
        // Update options with index
        internalOptions.index = index;
        // Parse the document at this point
        documents[docStartIndex + i] = (0, deserializer_1.internalDeserialize)(bufferData, internalOptions);
        // Adjust index by the document size
        index = index + size;
    }
    // Return object containing end index of parsing and list of documents
    return index;
}
