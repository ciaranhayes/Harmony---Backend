"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBRef = void 0;
exports.isDBRefLike = isDBRefLike;
const bson_value_1 = require("./bson_value");
const utils_1 = require("./parser/utils");
/** @internal */
function isDBRefLike(value) {
    return (value != null &&
        typeof value === 'object' &&
        '$id' in value &&
        value.$id != null &&
        '$ref' in value &&
        typeof value.$ref === 'string' &&
        // If '$db' is defined it MUST be a string, otherwise it should be absent
        (!('$db' in value) || ('$db' in value && typeof value.$db === 'string')));
}
/**
 * A class representation of the BSON DBRef type.
 * @public
 * @category BSONType
 */
class DBRef extends bson_value_1.BSONValue {
    get _bsontype() {
        return 'DBRef';
    }
    /**
     * @param collection - the collection name.
     * @param oid - the reference ObjectId.
     * @param db - optional db name, if omitted the reference is local to the current db.
     */
    constructor(collection, oid, db, fields) {
        super();
        // check if namespace has been provided
        const parts = collection.split('.');
        if (parts.length === 2) {
            db = parts.shift();
            collection = parts.shift();
        }
        this.collection = collection;
        this.oid = oid;
        this.db = db;
        this.fields = fields || {};
    }
    // Property provided for compatibility with the 1.x parser
    // the 1.x parser used a "namespace" property, while 4.x uses "collection"
    /** @internal */
    get namespace() {
        return this.collection;
    }
    set namespace(value) {
        this.collection = value;
    }
    toJSON() {
        const o = Object.assign({
            $ref: this.collection,
            $id: this.oid
        }, this.fields);
        if (this.db != null)
            o.$db = this.db;
        return o;
    }
    /** @internal */
    toExtendedJSON(options) {
        options = options || {};
        let o = {
            $ref: this.collection,
            $id: this.oid
        };
        if (options.legacy) {
            return o;
        }
        if (this.db)
            o.$db = this.db;
        o = Object.assign(o, this.fields);
        return o;
    }
    /** @internal */
    static fromExtendedJSON(doc) {
        const copy = Object.assign({}, doc);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
    inspect(depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : (inspect = utils_1.defaultInspect);
        const args = [
            inspect(this.namespace, options),
            inspect(this.oid, options),
            ...(this.db ? [inspect(this.db, options)] : []),
            ...(Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : [])
        ];
        args[1] = inspect === utils_1.defaultInspect ? `new ObjectId(${args[1]})` : args[1];
        return `new DBRef(${args.join(', ')})`;
    }
}
exports.DBRef = DBRef;
