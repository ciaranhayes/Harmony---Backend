"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Int32 = void 0;
const bson_value_1 = require("./bson_value");
const constants_1 = require("./constants");
const error_1 = require("./error");
const utils_1 = require("./parser/utils");
const string_utils_1 = require("./utils/string_utils");
/**
 * A class representation of a BSON Int32 type.
 * @public
 * @category BSONType
 */
class Int32 extends bson_value_1.BSONValue {
    get _bsontype() {
        return 'Int32';
    }
    /**
     * Create an Int32 type
     *
     * @param value - the number we want to represent as an int32.
     */
    constructor(value) {
        super();
        if (value instanceof Number) {
            value = value.valueOf();
        }
        this.value = +value | 0;
    }
    /**
     * Attempt to create an Int32 type from string.
     *
     * This method will throw a BSONError on any string input that is not representable as an Int32.
     * Notably, this method will also throw on the following string formats:
     * - Strings in non-decimal formats (exponent notation, binary, hex, or octal digits)
     * - Strings non-numeric and non-leading sign characters (ex: '2.0', '24,000')
     * - Strings with leading and/or trailing whitespace
     *
     * Strings with leading zeros, however, are allowed.
     *
     * @param value - the string we want to represent as an int32.
     */
    static fromString(value) {
        const cleanedValue = (0, string_utils_1.removeLeadingZerosAndExplicitPlus)(value);
        const coercedValue = Number(value);
        if (constants_1.BSON_INT32_MAX < coercedValue) {
            throw new error_1.BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
        }
        else if (constants_1.BSON_INT32_MIN > coercedValue) {
            throw new error_1.BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
        }
        else if (!Number.isSafeInteger(coercedValue)) {
            throw new error_1.BSONError(`Input: '${value}' is not a safe integer`);
        }
        else if (coercedValue.toString() !== cleanedValue) {
            // catch all case
            throw new error_1.BSONError(`Input: '${value}' is not a valid Int32 string`);
        }
        return new Int32(coercedValue);
    }
    /**
     * Access the number value.
     *
     * @returns returns the wrapped int32 number.
     */
    valueOf() {
        return this.value;
    }
    toString(radix) {
        return this.value.toString(radix);
    }
    toJSON() {
        return this.value;
    }
    /** @internal */
    toExtendedJSON(options) {
        if (options && (options.relaxed || options.legacy))
            return this.value;
        return { $numberInt: this.value.toString() };
    }
    /** @internal */
    static fromExtendedJSON(doc, options) {
        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
    inspect(depth, options, inspect) {
        inspect !== null && inspect !== void 0 ? inspect : (inspect = utils_1.defaultInspect);
        return `new Int32(${inspect(this.value, options)})`;
    }
}
exports.Int32 = Int32;
