"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.internalDeserialize = internalDeserialize;
const binary_1 = require("../binary");
const code_1 = require("../code");
const constants = __importStar(require("../constants"));
const db_ref_1 = require("../db_ref");
const decimal128_1 = require("../decimal128");
const double_1 = require("../double");
const error_1 = require("../error");
const int_32_1 = require("../int_32");
const long_1 = require("../long");
const max_key_1 = require("../max_key");
const min_key_1 = require("../min_key");
const objectid_1 = require("../objectid");
const regexp_1 = require("../regexp");
const symbol_1 = require("../symbol");
const timestamp_1 = require("../timestamp");
const byte_utils_1 = require("../utils/byte_utils");
const number_utils_1 = require("../utils/number_utils");
// Internal long versions
const JS_INT_MAX_LONG = long_1.Long.fromNumber(constants.JS_INT_MAX);
const JS_INT_MIN_LONG = long_1.Long.fromNumber(constants.JS_INT_MIN);
function internalDeserialize(buffer, options, isArray) {
    options = options == null ? {} : options;
    const index = options && options.index ? options.index : 0;
    // Read the document size
    const size = number_utils_1.NumberUtils.getInt32LE(buffer, index);
    if (size < 5) {
        throw new error_1.BSONError(`bson size must be >= 5, is ${size}`);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {
        throw new error_1.BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {
        throw new error_1.BSONError(`buffer length ${buffer.length} must === bson size ${size}`);
    }
    if (size + index > buffer.byteLength) {
        throw new error_1.BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);
    }
    // Illegal end value
    if (buffer[index + size - 1] !== 0) {
        throw new error_1.BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    // Start deserialization
    return deserializeObject(buffer, index, options, isArray);
}
const allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
function deserializeObject(buffer, index, options, isArray = false) {
    var _a, _b, _c, _d;
    const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
    // Return raw bson buffer instead of parsing it
    const raw = options['raw'] == null ? false : options['raw'];
    // Return BSONRegExp objects instead of native regular expressions
    const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;
    // Controls the promotion of values vs wrapper classes
    const promoteBuffers = (_a = options.promoteBuffers) !== null && _a !== void 0 ? _a : false;
    const promoteLongs = (_b = options.promoteLongs) !== null && _b !== void 0 ? _b : true;
    const promoteValues = (_c = options.promoteValues) !== null && _c !== void 0 ? _c : true;
    const useBigInt64 = (_d = options.useBigInt64) !== null && _d !== void 0 ? _d : false;
    if (useBigInt64 && !promoteValues) {
        throw new error_1.BSONError('Must either request bigint or Long for int64 deserialization');
    }
    if (useBigInt64 && !promoteLongs) {
        throw new error_1.BSONError('Must either request bigint or Long for int64 deserialization');
    }
    // Ensures default validation option if none given
    const validation = options.validation == null ? { utf8: true } : options.validation;
    // Shows if global utf-8 validation is enabled or disabled
    let globalUTFValidation = true;
    // Reflects utf-8 validation setting regardless of global or specific key validation
    let validationSetting;
    // Set of keys either to enable or disable validation on
    let utf8KeysSet;
    // Check for boolean uniformity and empty validation option
    const utf8ValidatedKeys = validation.utf8;
    if (typeof utf8ValidatedKeys === 'boolean') {
        validationSetting = utf8ValidatedKeys;
    }
    else {
        globalUTFValidation = false;
        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {
            return utf8ValidatedKeys[key];
        });
        if (utf8ValidationValues.length === 0) {
            throw new error_1.BSONError('UTF-8 validation setting cannot be empty');
        }
        if (typeof utf8ValidationValues[0] !== 'boolean') {
            throw new error_1.BSONError('Invalid UTF-8 validation option, must specify boolean values');
        }
        validationSetting = utf8ValidationValues[0];
        // Ensures boolean uniformity in utf-8 validation (all true or all false)
        if (!utf8ValidationValues.every(item => item === validationSetting)) {
            throw new error_1.BSONError('Invalid UTF-8 validation option - keys must be all true or all false');
        }
    }
    // Add keys to set that will either be validated or not based on validationSetting
    if (!globalUTFValidation) {
        utf8KeysSet = new Set();
        for (const key of Object.keys(utf8ValidatedKeys)) {
            utf8KeysSet.add(key);
        }
    }
    // Set the start index
    const startIndex = index;
    // Validate that we have at least 4 bytes of buffer
    if (buffer.length < 5)
        throw new error_1.BSONError('corrupt bson message < 5 bytes long');
    // Read the document size
    const size = number_utils_1.NumberUtils.getInt32LE(buffer, index);
    index += 4;
    // Ensure buffer is valid size
    if (size < 5 || size > buffer.length)
        throw new error_1.BSONError('corrupt bson message');
    // Create holding object
    const object = isArray ? [] : {};
    // Used for arrays to skip having to perform utf8 decoding
    let arrayIndex = 0;
    const done = false;
    let isPossibleDBRef = isArray ? false : null;
    // While we have more left data left keep parsing
    while (!done) {
        // Read the type
        const elementType = buffer[index++];
        // If we get a zero it's the last byte, exit
        if (elementType === 0)
            break;
        // Get the start search index
        let i = index;
        // Locate the end of the c string
        while (buffer[i] !== 0x00 && i < buffer.length) {
            i++;
        }
        // If are at the end of the buffer there is a problem with the document
        if (i >= buffer.byteLength)
            throw new error_1.BSONError('Bad BSON Document: illegal CString');
        // Represents the key
        const name = isArray ? arrayIndex++ : byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
        // shouldValidateKey is true if the key should be validated, false otherwise
        let shouldValidateKey = true;
        if (globalUTFValidation || (utf8KeysSet === null || utf8KeysSet === void 0 ? void 0 : utf8KeysSet.has(name))) {
            shouldValidateKey = validationSetting;
        }
        else {
            shouldValidateKey = !validationSetting;
        }
        if (isPossibleDBRef !== false && name[0] === '$') {
            isPossibleDBRef = allowedDBRefKeys.test(name);
        }
        let value;
        index = i + 1;
        if (elementType === constants.BSON_DATA_STRING) {
            const stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            value = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            index = index + stringSize;
        }
        else if (elementType === constants.BSON_DATA_OID) {
            const oid = byte_utils_1.ByteUtils.allocateUnsafe(12);
            for (let i = 0; i < 12; i++)
                oid[i] = buffer[index + i];
            value = new objectid_1.ObjectId(oid);
            index = index + 12;
        }
        else if (elementType === constants.BSON_DATA_INT && promoteValues === false) {
            value = new int_32_1.Int32(number_utils_1.NumberUtils.getInt32LE(buffer, index));
            index += 4;
        }
        else if (elementType === constants.BSON_DATA_INT) {
            value = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
        }
        else if (elementType === constants.BSON_DATA_NUMBER) {
            value = number_utils_1.NumberUtils.getFloat64LE(buffer, index);
            index += 8;
            if (promoteValues === false)
                value = new double_1.Double(value);
        }
        else if (elementType === constants.BSON_DATA_DATE) {
            const lowBits = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            const highBits = number_utils_1.NumberUtils.getInt32LE(buffer, index + 4);
            index += 8;
            value = new Date(new long_1.Long(lowBits, highBits).toNumber());
        }
        else if (elementType === constants.BSON_DATA_BOOLEAN) {
            if (buffer[index] !== 0 && buffer[index] !== 1)
                throw new error_1.BSONError('illegal boolean type value');
            value = buffer[index++] === 1;
        }
        else if (elementType === constants.BSON_DATA_OBJECT) {
            const _index = index;
            const objectSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            if (objectSize <= 0 || objectSize > buffer.length - index)
                throw new error_1.BSONError('bad embedded document length in bson');
            // We have a raw value
            if (raw) {
                value = buffer.subarray(index, index + objectSize);
            }
            else {
                let objectOptions = options;
                if (!globalUTFValidation) {
                    objectOptions = Object.assign(Object.assign({}, options), { validation: { utf8: shouldValidateKey } });
                }
                value = deserializeObject(buffer, _index, objectOptions, false);
            }
            index = index + objectSize;
        }
        else if (elementType === constants.BSON_DATA_ARRAY) {
            const _index = index;
            const objectSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            let arrayOptions = options;
            // Stop index
            const stopIndex = index + objectSize;
            // All elements of array to be returned as raw bson
            if (fieldsAsRaw && fieldsAsRaw[name]) {
                arrayOptions = Object.assign(Object.assign({}, options), { raw: true });
            }
            if (!globalUTFValidation) {
                arrayOptions = Object.assign(Object.assign({}, arrayOptions), { validation: { utf8: shouldValidateKey } });
            }
            value = deserializeObject(buffer, _index, arrayOptions, true);
            index = index + objectSize;
            if (buffer[index - 1] !== 0)
                throw new error_1.BSONError('invalid array terminator byte');
            if (index !== stopIndex)
                throw new error_1.BSONError('corrupted array bson');
        }
        else if (elementType === constants.BSON_DATA_UNDEFINED) {
            value = undefined;
        }
        else if (elementType === constants.BSON_DATA_NULL) {
            value = null;
        }
        else if (elementType === constants.BSON_DATA_LONG) {
            if (useBigInt64) {
                value = number_utils_1.NumberUtils.getBigInt64LE(buffer, index);
                index += 8;
            }
            else {
                // Unpack the low and high bits
                const lowBits = number_utils_1.NumberUtils.getInt32LE(buffer, index);
                const highBits = number_utils_1.NumberUtils.getInt32LE(buffer, index + 4);
                index += 8;
                const long = new long_1.Long(lowBits, highBits);
                // Promote the long if possible
                if (promoteLongs && promoteValues === true) {
                    value =
                        long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)
                            ? long.toNumber()
                            : long;
                }
                else {
                    value = long;
                }
            }
        }
        else if (elementType === constants.BSON_DATA_DECIMAL128) {
            // Buffer to contain the decimal bytes
            const bytes = byte_utils_1.ByteUtils.allocateUnsafe(16);
            // Copy the next 16 bytes into the bytes buffer
            for (let i = 0; i < 16; i++)
                bytes[i] = buffer[index + i];
            // Update index
            index = index + 16;
            // Assign the new Decimal128 value
            value = new decimal128_1.Decimal128(bytes);
        }
        else if (elementType === constants.BSON_DATA_BINARY) {
            let binarySize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            const totalBinarySize = binarySize;
            const subType = buffer[index++];
            // Did we have a negative binary size, throw
            if (binarySize < 0)
                throw new error_1.BSONError('Negative binary type element size found');
            // Is the length longer than the document
            if (binarySize > buffer.byteLength)
                throw new error_1.BSONError('Binary type size larger than document size');
            // If we have subtype 2 skip the 4 bytes for the size
            if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
                binarySize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
                index += 4;
                if (binarySize < 0)
                    throw new error_1.BSONError('Negative binary type element size found for subtype 0x02');
                if (binarySize > totalBinarySize - 4)
                    throw new error_1.BSONError('Binary type with subtype 0x02 contains too long binary size');
                if (binarySize < totalBinarySize - 4)
                    throw new error_1.BSONError('Binary type with subtype 0x02 contains too short binary size');
            }
            if (promoteBuffers && promoteValues) {
                value = byte_utils_1.ByteUtils.toLocalBufferType(buffer.subarray(index, index + binarySize));
            }
            else {
                value = new binary_1.Binary(buffer.subarray(index, index + binarySize), subType);
                if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW && binary_1.UUID.isValid(value)) {
                    value = value.toUUID();
                }
            }
            // Update the index
            index = index + binarySize;
        }
        else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) {
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            const source = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            // Create the regexp
            index = i + 1;
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            const regExpOptions = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            index = i + 1;
            // For each option add the corresponding one for javascript
            const optionsArray = new Array(regExpOptions.length);
            // Parse options
            for (i = 0; i < regExpOptions.length; i++) {
                switch (regExpOptions[i]) {
                    case 'm':
                        optionsArray[i] = 'm';
                        break;
                    case 's':
                        optionsArray[i] = 'g';
                        break;
                    case 'i':
                        optionsArray[i] = 'i';
                        break;
                }
            }
            value = new RegExp(source, optionsArray.join(''));
        }
        else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) {
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            const source = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            index = i + 1;
            // Get the start search index
            i = index;
            // Locate the end of the c string
            while (buffer[i] !== 0x00 && i < buffer.length) {
                i++;
            }
            // If are at the end of the buffer there is a problem with the document
            if (i >= buffer.length)
                throw new error_1.BSONError('Bad BSON Document: illegal CString');
            // Return the C string
            const regExpOptions = byte_utils_1.ByteUtils.toUTF8(buffer, index, i, false);
            index = i + 1;
            // Set the object
            value = new regexp_1.BSONRegExp(source, regExpOptions);
        }
        else if (elementType === constants.BSON_DATA_SYMBOL) {
            const stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            const symbol = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            value = promoteValues ? symbol : new symbol_1.BSONSymbol(symbol);
            index = index + stringSize;
        }
        else if (elementType === constants.BSON_DATA_TIMESTAMP) {
            value = new timestamp_1.Timestamp({
                i: number_utils_1.NumberUtils.getUint32LE(buffer, index),
                t: number_utils_1.NumberUtils.getUint32LE(buffer, index + 4)
            });
            index += 8;
        }
        else if (elementType === constants.BSON_DATA_MIN_KEY) {
            value = new min_key_1.MinKey();
        }
        else if (elementType === constants.BSON_DATA_MAX_KEY) {
            value = new max_key_1.MaxKey();
        }
        else if (elementType === constants.BSON_DATA_CODE) {
            const stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            const functionString = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            value = new code_1.Code(functionString);
            // Update parse index position
            index = index + stringSize;
        }
        else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {
            const totalSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            // Element cannot be shorter than totalSize + stringSize + documentSize + terminator
            if (totalSize < 4 + 4 + 4 + 1) {
                throw new error_1.BSONError('code_w_scope total size shorter minimum expected length');
            }
            // Get the code string size
            const stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            // Check if we have a valid string
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0) {
                throw new error_1.BSONError('bad string length in bson');
            }
            // Javascript function
            const functionString = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            // Update parse index position
            index = index + stringSize;
            // Parse the element
            const _index = index;
            // Decode the size of the object document
            const objectSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            // Decode the scope object
            const scopeObject = deserializeObject(buffer, _index, options, false);
            // Adjust the index
            index = index + objectSize;
            // Check if field length is too short
            if (totalSize < 4 + 4 + objectSize + stringSize) {
                throw new error_1.BSONError('code_w_scope total size is too short, truncating scope');
            }
            // Check if totalSize field is too long
            if (totalSize > 4 + 4 + objectSize + stringSize) {
                throw new error_1.BSONError('code_w_scope total size is too long, clips outer document');
            }
            value = new code_1.Code(functionString, scopeObject);
        }
        else if (elementType === constants.BSON_DATA_DBPOINTER) {
            // Get the code string size
            const stringSize = number_utils_1.NumberUtils.getInt32LE(buffer, index);
            index += 4;
            // Check if we have a valid string
            if (stringSize <= 0 ||
                stringSize > buffer.length - index ||
                buffer[index + stringSize - 1] !== 0)
                throw new error_1.BSONError('bad string length in bson');
            // Namespace
            const namespace = byte_utils_1.ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);
            // Update parse index position
            index = index + stringSize;
            // Read the oid
            const oidBuffer = byte_utils_1.ByteUtils.allocateUnsafe(12);
            for (let i = 0; i < 12; i++)
                oidBuffer[i] = buffer[index + i];
            const oid = new objectid_1.ObjectId(oidBuffer);
            // Update the index
            index = index + 12;
            // Upgrade to DBRef type
            value = new db_ref_1.DBRef(namespace, oid);
        }
        else {
            throw new error_1.BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
        }
        if (name === '__proto__') {
            Object.defineProperty(object, name, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
        else {
            object[name] = value;
        }
    }
    // Check if the deserialization was against a valid array/object
    if (size !== index - startIndex) {
        if (isArray)
            throw new error_1.BSONError('corrupt array bson');
        throw new error_1.BSONError('corrupt object bson');
    }
    // if we did not find "$ref", "$id", "$db", or found an extraneous $key, don't make a DBRef
    if (!isPossibleDBRef)
        return object;
    if ((0, db_ref_1.isDBRefLike)(object)) {
        const copy = Object.assign({}, object);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new db_ref_1.DBRef(object.$ref, object.$id, object.$db, copy);
    }
    return object;
}
