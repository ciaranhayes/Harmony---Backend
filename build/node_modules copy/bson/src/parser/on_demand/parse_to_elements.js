"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseToElements = parseToElements;
const error_1 = require("../../error");
const number_utils_1 = require("../../utils/number_utils");
function getSize(source, offset) {
    try {
        return number_utils_1.NumberUtils.getNonnegativeInt32LE(source, offset);
    }
    catch (cause) {
        throw new error_1.BSONOffsetError('BSON size cannot be negative', offset, { cause });
    }
}
/**
 * Searches for null terminator of a BSON element's value (Never the document null terminator)
 * **Does not** bounds check since this should **ONLY** be used within parseToElements which has asserted that `bytes` ends with a `0x00`.
 * So this will at most iterate to the document's terminator and error if that is the offset reached.
 */
function findNull(bytes, offset) {
    let nullTerminatorOffset = offset;
    for (; bytes[nullTerminatorOffset] !== 0x00; nullTerminatorOffset++)
        ;
    if (nullTerminatorOffset === bytes.length - 1) {
        // We reached the null terminator of the document, not a value's
        throw new error_1.BSONOffsetError('Null terminator not found', offset);
    }
    return nullTerminatorOffset;
}
/**
 * @public
 * @experimental
 */
function parseToElements(bytes, startOffset = 0) {
    startOffset !== null && startOffset !== void 0 ? startOffset : (startOffset = 0);
    if (bytes.length < 5) {
        throw new error_1.BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
    }
    const documentSize = getSize(bytes, startOffset);
    if (documentSize > bytes.length - startOffset) {
        throw new error_1.BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
    }
    if (bytes[startOffset + documentSize - 1] !== 0x00) {
        throw new error_1.BSONOffsetError('BSON documents must end in 0x00', startOffset + documentSize);
    }
    const elements = [];
    let offset = startOffset + 4;
    while (offset <= documentSize + startOffset) {
        const type = bytes[offset];
        offset += 1;
        if (type === 0) {
            if (offset - startOffset !== documentSize) {
                throw new error_1.BSONOffsetError(`Invalid 0x00 type byte`, offset);
            }
            break;
        }
        const nameOffset = offset;
        const nameLength = findNull(bytes, offset) - nameOffset;
        offset += nameLength + 1;
        let length;
        if (type === 1 /* BSONElementType.double */ ||
            type === 18 /* BSONElementType.long */ ||
            type === 9 /* BSONElementType.date */ ||
            type === 17 /* BSONElementType.timestamp */) {
            length = 8;
        }
        else if (type === 16 /* BSONElementType.int */) {
            length = 4;
        }
        else if (type === 7 /* BSONElementType.objectId */) {
            length = 12;
        }
        else if (type === 19 /* BSONElementType.decimal */) {
            length = 16;
        }
        else if (type === 8 /* BSONElementType.bool */) {
            length = 1;
        }
        else if (type === 10 /* BSONElementType.null */ ||
            type === 6 /* BSONElementType.undefined */ ||
            type === 127 /* BSONElementType.maxKey */ ||
            type === 255 /* BSONElementType.minKey */) {
            length = 0;
        }
        // Needs a size calculation
        else if (type === 11 /* BSONElementType.regex */) {
            length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
        }
        else if (type === 3 /* BSONElementType.object */ ||
            type === 4 /* BSONElementType.array */ ||
            type === 15 /* BSONElementType.javascriptWithScope */) {
            length = getSize(bytes, offset);
        }
        else if (type === 2 /* BSONElementType.string */ ||
            type === 5 /* BSONElementType.binData */ ||
            type === 12 /* BSONElementType.dbPointer */ ||
            type === 13 /* BSONElementType.javascript */ ||
            type === 14 /* BSONElementType.symbol */) {
            length = getSize(bytes, offset) + 4;
            if (type === 5 /* BSONElementType.binData */) {
                // binary subtype
                length += 1;
            }
            if (type === 12 /* BSONElementType.dbPointer */) {
                // dbPointer's objectId
                length += 12;
            }
        }
        else {
            throw new error_1.BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, '0')} type byte`, offset);
        }
        if (length > documentSize) {
            throw new error_1.BSONOffsetError('value reports length larger than document', offset);
        }
        elements.push([type, nameOffset, nameLength, offset, length]);
        offset += length;
    }
    return elements;
}
